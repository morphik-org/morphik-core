name: Build Docker Image

on:
  pull_request
  
permissions:
  contents: read

jobs:
  docker-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          sudo docker builder prune -a --force
          df -h

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/morphik-core
          tags: |
            type=ref,event=pr
            type=sha,prefix=pr-{{branch}}-
            
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./dockerfile
          push: false
          load: true
          tags: |
            ${{ steps.meta.outputs.tags }}
            morphik-core:test
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          # Remove cache-to for PR builds to save disk space 
          
      - name: Test Docker container
        run: |
          # Use the local test tag instead of the registry tag
          IMAGE_TAG="morphik-core:test"
          echo "Testing image: $IMAGE_TAG"
          
          # Create a minimal config file for testing
          cat > morphik.toml.test << 'EOF'
          [api]
          host = "0.0.0.0"
          port = 8000
          reload = true
          
          [auth]
          jwt_algorithm = "HS256"
          dev_mode = true  # Enabled by default for easier local development
          dev_entity_id = "dev_user"  # Default dev user ID
          dev_entity_type = "developer"  # Default dev entity type
          dev_permissions = ["read", "write", "admin"]  # Default dev permissions
          
          #### Registered models
          [registered_models]
          
          # OpenAI models
          openai_gpt4 = { model_name = "gpt-4" }
          openai_gpt4-1 = { model_name = "gpt-4.1" }
          openai_gpt4o = { model_name = "gpt-4o" }
          
          # Embedding models
          openai_embedding = { model_name = "text-embedding-3-small" }
          openai_embedding_large = { model_name = "text-embedding-3-large" }
          
          #### Component configurations ####
          
          [agent]
          model = "openai_gpt4-1"
          
          [completion]
          model = "openai_gpt4o"
          default_max_tokens = "1000"
          default_temperature = 0.5
          
          [document_analysis]
          model = "openai_gpt4-1"
          
          [database]
          provider = "postgres"
          # Connection pool settings
          pool_size = 10           # Maximum number of connections in the pool
          max_overflow = 15        # Maximum number of connections that can be created beyond pool_size
          pool_recycle = 3600      # Time in seconds after which a connection is recycled (1 hour)
          pool_timeout = 10        # Seconds to wait for a connection from the pool
          pool_pre_ping = true     # Check connection viability before using it from the pool
          max_retries = 3          # Number of retries for database operations
          retry_delay = 1.0        # Initial delay between retries in seconds
          
          [embedding]
          model = "openai_embedding"  # Reference to registered model
          dimensions = 1536
          similarity_metric = "cosine"
          
          [parser]
          chunk_size = 6000
          chunk_overlap = 300
          use_unstructured_api = false
          use_contextual_chunking = false
          contextual_chunking_model = "openai_gpt4-1"  # Reference to a key in registered_models
          
          [parser.vision]
          model = "openai_gpt4-1"  # Reference to a key in registered_models
          frame_sample_rate = -1  # Set to -1 to disable frame captioning
          
          [reranker]
          use_reranker = true
          provider = "flag"
          model_name = "BAAI/bge-reranker-large"
          query_max_length = 256
          passage_max_length = 512
          use_fp16 = true
          device = "cpu" # use "cpu" if on docker and using a mac, "cuda" if cuda enabled device
          
          [storage]
          provider = "local"
          storage_path = "./storage"
          
          # [storage]
          # provider = "aws-s3"
          # region = "us-east-2"
          # bucket_name = "morphik-s3-storage"
          
          [vector_store]
          provider = "pgvector"
          
          [rules]
          model = "openai_gpt4-1"
          batch_size = 4096
          
          [morphik]
          enable_colpali = true
          mode = "self_hosted"  # "cloud" or "self_hosted"
          api_domain = "api.morphik.ai"  # API domain for cloud URIs
          
          [redis]
          host = "redis"  # use "redis" for docker
          port = 6379
          
          [graph]
          model = "openai_gpt4-1"
          enable_entity_resolution = true
          EOF
          
          # Create a custom network for the containers to communicate
          NETWORK_NAME="morphik-test-network"
          docker network create $NETWORK_NAME

          # Start pgvector PostgreSQL container
          echo "Starting pgvector PostgreSQL container..."
          DB_CONTAINER_ID=$(docker run -d \
            --name pgvector-test \
            --network $NETWORK_NAME \
            -e POSTGRES_USER=morphik \
            -e POSTGRES_PASSWORD=morphik \
            -e POSTGRES_DB=morphik \
            -p 5432:5432 \
            ankane/pgvector:latest)

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker exec $DB_CONTAINER_ID pg_isready -U morphik -d morphik; then
              echo "PostgreSQL is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "PostgreSQL failed to start"
              docker logs $DB_CONTAINER_ID
              exit 1
            fi
            sleep 1
          done

          # Enable pgvector extension
          echo "Enabling pgvector extension..."
          docker exec $DB_CONTAINER_ID psql -U morphik -d morphik -c 'CREATE EXTENSION IF NOT EXISTS vector;'

          # Start application container
          echo "Starting application container..."
          CONTAINER_ID=$(docker run -d \
            --network $NETWORK_NAME \
            -p 8000:8000 \
            -e POSTGRES_URI="postgresql://morphik:morphik@pgvector-test:5432/morphik" \
            -v "$(pwd)/morphik.toml:/app/morphik.toml" \
            "$IMAGE_TAG")
          
          echo "Started container: $CONTAINER_ID"
          
          # Wait for server to be ready with 60 second timeout
          timeout=60
          interval=2
          elapsed=0
          
          echo "Waiting for server to be ready..."
          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost:8000/ping > /dev/null 2>&1; then
              echo "✅ Server is responding to /ping endpoint"
              break
            fi
            
            echo "⏳ Waiting for server... (${elapsed}s/${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          # Check if we timed out
          if [ $elapsed -ge $timeout ]; then
            echo "❌ Server failed to respond within ${timeout} seconds"
            echo "Container logs:"
            docker logs "$CONTAINER_ID"
            echo "Database logs:"
            docker logs "$DB_CONTAINER_ID"
            docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
            docker rm "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
            docker network rm "$NETWORK_NAME" || true
            exit 1
          fi
          
          # Verify the response is actually 200
          response_code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/ping)
          if [ "$response_code" -ne 200 ]; then
            echo "❌ Unexpected response code: $response_code"
            echo "Container logs:"
            docker logs "$CONTAINER_ID"
            echo "Database logs:"
            docker logs "$DB_CONTAINER_ID"
            docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
            docker rm "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
            docker network rm "$NETWORK_NAME" || true
            exit 1
          fi
          
          echo "✅ Tests passed!"
          docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
          docker rm "$CONTAINER_ID" "$DB_CONTAINER_ID" || true
          docker network rm "$NETWORK_NAME" || true
          echo "✅ Test completed successfully"